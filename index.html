<!--
To do:
split into multiple code files
Controls for:
- Start/stop animation
- Randomize inputs
- control amp/freq of animation
- other key controls?
Want to be able to control scale / size / number of light blobs
Image / video export
Background color control?
Text below screen (canvas should take up entire screen though)
Ability to add this shader effect on top of an image?
Presets / seed choice??
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Komorebi - Sunlight Through Trees</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
</head>
<body>
    <canvas id="komorebi"></canvas>
    <button id="refreshButton">New Pattern</button>

    <div id="textOverlay">
        <p>Komorebi - Sunlight Through Trees</p>
        <p id="seedIndicator">Seed:</p>
    </div>

    <div id="videoRecordingMessageDiv" class="hidden sticky-top">
        Video recording underway. Press menu button or "v" to stop. The video will save to your downloads folder after.
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        
        uniform vec2 resolution;
        uniform float time;
        uniform float seed;
        
        // GUI-controlled parameters
        uniform float timeScale;
        uniform float patternAmp;
        uniform float patternFreq;
        uniform float bloomStrength;
        uniform float saturation;
        uniform float grainAmount;
        uniform vec3 colorTint;
        uniform float minCircleSize;
        uniform float minCircleThreshold;
        uniform float verticalFlowFactor;

        // Noise functions
        float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        
        float permute(float x) { return mod289(((x*34.0)+1.0)*x); }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        
        float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        // Random function that uses the seed
        float rand(vec3 co) {
            return fract(sin(dot(co.xyz + vec3(seed * 0.1), vec3(12.9898, 78.233, 53.539))) * 43758.5453);
        }
        
        // Simplex noise
        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                -0.577350269189626, 0.024390243902439);
            
            vec2 i  = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
            m = m * m;
            m = m * m;
            
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            
            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
            
            vec3 g;
            g.x = a0.x * x0.x + h.x * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }
        
        // Create larger, more prominent color patches with seed-based randomness
        float fbm(vec2 p) {
            float sum = 0.0;
            float amp = patternAmp;
            float freq = patternFreq;
            // Add seed-based offset for variation between refreshes
            vec2 seedOffset = vec2(sin(seed), cos(seed * 1.5)) * 3.0;
            
            for(int i = 0; i < 3; i++) {
                // Add unique seed-influenced offset for each octave
                vec2 octaveOffset = seedOffset * (0.5 + float(i) * 0.1);
                sum += amp * snoise((p + octaveOffset) * freq);
                amp *= 0.1;
                freq *= 0.1;
            }
            return sum * 0.5 + 0.5;
        }
        
        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            
            // Adjust aspect ratio
            uv.x *= resolution.x / resolution.y;
            
            // Apply timeScale from GUI
            float slowTime = time * timeScale;
            
            // Create seed-influenced flow vectors for different pattern on each refresh
            vec2 flow1 = vec2(
                sin(slowTime * 0.31 + seed * 0.42) * 0.3 + sin(slowTime * 0.17 + seed * 0.23) * 0.2,
                cos(slowTime * 0.27 + seed * 0.31) * 0.3 + cos(slowTime * 0.13 + seed * 0.17) * 0.2
            );
            
            vec2 flow2 = vec2(
                sin(slowTime * 0.19 + 1.7 + seed * 0.13) * 0.4 + sin(slowTime * 0.23 + seed * 0.29) * 0.1,
                cos(slowTime * 0.22 + 2.3 + seed * 0.19) * 0.4 + cos(slowTime * 0.11 + seed * 0.33) * 0.1
            );
            
            vec2 flow3 = vec2(
                sin(slowTime * 0.15 + 3.4 + seed * 0.25) * 0.25 + sin(slowTime * 0.29 + seed * 0.11) * 0.15,
                cos(slowTime * 0.18 + 1.2 + seed * 0.37) * 0.25 + cos(slowTime * 0.33 + seed * 0.27) * 0.15
            );
            
            float noiseScale1 = 10000.0;
            
            // Create depth layers with seed randomization
            float depthOffset1 = sin(slowTime * 0.02 + seed * 0.5) * 6.15;
            float depthOffset2 = sin(slowTime * 0.02 + seed * 0.7) * 12.25;
            
            // Apply depth offsets to create 3D layering effect
            vec2 depthFlow1 = flow1 + vec2(depthOffset1, depthOffset2) * 2.0;
            
            // Main light layer with enhanced 3D liquid motion
            float lightPattern = fbm(uv * noiseScale1 + depthFlow1);
            
            // Adjust weights using seed for more variation
            float combinedPattern = lightPattern * (1.0 + sin(seed) * 0.15);

            // Start with a seed-influenced base color
            vec3 baseColor = vec3(
                0.6 + sin(seed * 0.4) * 0.1,
                0.9 + cos(seed * 0.3) * 0.05,
                0.92 + sin(seed * 0.5) * 0.05
            );
            
            // Define pastel colors with slight seed-based variations
            float colorSeed1 = sin(seed * 0.73) * 0.88;
            float colorSeed2 = cos(seed * 0.51) * 0.28;
            float colorSeed3 = sin(seed * 0.92) * 0.48;
            
            vec3 pastelGreen = vec3(0.85 + colorSeed1, 0.95 + colorSeed2, 0.85 + colorSeed3);
            vec3 pastelBlue = vec3(0.85 + colorSeed3, 0.9 + colorSeed1, 0.98 + colorSeed2);
            vec3 pastelPink = vec3(0.98 + colorSeed2, 0.88 + colorSeed3, 0.92 + colorSeed1);
            vec3 pastelYellow = vec3(0.98 + colorSeed3, 0.95 + colorSeed1, 0.85 + colorSeed2);
            vec3 brightPink = vec3(0.98 + colorSeed1, 0.85 + colorSeed2, 0.92 + colorSeed3);
            
            // Additional pastel colors with seed variations
            vec3 pastelLavender = vec3(0.92 + colorSeed2, 0.88 + colorSeed3, 0.98 + colorSeed1);
            vec3 pastelPeach = vec3(0.98 + colorSeed3, 0.92 + colorSeed1, 0.87 + colorSeed2);
            vec3 pastelTeal = vec3(0.85 + colorSeed1, 0.95 + colorSeed2, 0.95 + colorSeed3);
            vec3 pastelCoral = vec3(0.98 + colorSeed2, 0.88 + colorSeed1, 0.85 + colorSeed3);
            vec3 pastelMint = vec3(0.88 + colorSeed3, 0.98 + colorSeed2, 0.91 + colorSeed1);
            vec3 pastelLilac = vec3(0.91 + colorSeed1, 0.85 + colorSeed3, 0.98 + colorSeed2);
            vec3 pastelSkyBlue = vec3(0.85 + colorSeed2, 0.91 + colorSeed1, 0.98 + colorSeed3);
            
            // Using larger color patches with 3D liquid-like noise and seed influence
            float verticalFlow = sin(uv.y * 3.0 + slowTime * 0.2 + seed * 0.4) * verticalFlowFactor;
            
            // Creating more complex flow patterns for liquid movement
            vec2 liquidFlow1 = flow1 + vec2(verticalFlow, sin(uv.x * 2.5 + slowTime * 0.15 + seed * 0.3) * 0.2);
            vec2 liquidFlow2 = flow2 + vec2(cos(uv.y * 2.2 + slowTime * 0.1 + seed * 0.5) * 0.15, verticalFlow);
            vec2 liquidFlow3 = flow3 + vec2(verticalFlow * 0.5, cos(uv.x * 1.8 - slowTime * 0.12 + seed * 0.7) * 0.25);
            
            // Add seed-dependent scale factors for noise
            float noiseSeedFactor1 = 0.15 * (1.0 + sin(seed * 0.3) * 0.3);
            float noiseSeedFactor2 = 0.2 * (1.0 + cos(seed * 0.5) * 0.3);
            float noiseSeedFactor3 = 0.12 * (1.0 + sin(seed * 0.7) * 0.3);
            
            float colorNoise1 = fbm(uv * noiseSeedFactor1 + liquidFlow1 * 0.3);
            float colorNoise2 = fbm(uv * noiseSeedFactor2 + liquidFlow2 * 0.3);
            float colorNoise3 = fbm(uv * noiseSeedFactor3 + liquidFlow3 * 0.25);
            
            // Adjust thresholds with seed influence for variety
            float threshSeed1 = 0.0 + sin(seed * 0.4) * 0.15;
            float threshSeed2 = 0.15 + cos(seed * 0.6) * 0.15;
            float threshSeed3 = 0.25 + sin(seed * 0.8) * 0.15;
            
            float colorMixValue1 = smoothstep(0.0, threshSeed1, colorNoise1);
            float colorMixValue2 = smoothstep(0.0, threshSeed2, colorNoise2);
            float colorMixValue3 = smoothstep(0.0, threshSeed3, colorNoise3);
            
            // Start with base color and mix in expanded pastel palette
            vec3 colorVariation = baseColor;
            
            // Layer 1: Primary colors with seed-influenced mix factors
            float mixFactor1 = 2.2 + sin(seed * 0.3) * 0.5;
            float mixFactor2 = 2.0 + cos(seed * 0.5) * 0.5;
            float mixFactor3 = 2.0 + sin(seed * 0.7) * 0.5;
            float mixFactor4 = 2.0 + cos(seed * 0.9) * 0.5;
            
            colorVariation = mix(colorVariation, pastelBlue, colorMixValue1 * mixFactor1);
            colorVariation = mix(colorVariation, pastelPink, (1.0 - colorMixValue1) * colorMixValue2 * mixFactor2);
            colorVariation = mix(colorVariation, pastelGreen, colorMixValue2 * (1.0 - colorMixValue1) * mixFactor3);
            colorVariation = mix(colorVariation, pastelYellow, (1.0 - colorMixValue2) * colorMixValue1 * mixFactor4);
            
            // Layer 2: New pastel colors with seed-influenced mix factors
            float mixFactor5 = 1.8 + sin(seed * 1.1) * 0.4;
            float mixFactor6 = 1.8 + cos(seed * 1.3) * 0.4;
            float mixFactor7 = 1.7 + sin(seed * 1.5) * 0.4;
            float mixFactor8 = 1.6 + cos(seed * 1.7) * 0.4;
            float mixFactor9 = 1.5 + sin(seed * 1.9) * 0.4;
            
            colorVariation = mix(colorVariation, brightPink, (colorMixValue1 * colorMixValue2) * mixFactor5);
            colorVariation = mix(colorVariation, pastelLavender, (1.0 - colorMixValue3) * colorMixValue1 * mixFactor6);
            colorVariation = mix(colorVariation, pastelPeach, colorMixValue3 * (1.0 - colorMixValue2) * mixFactor7);
            colorVariation = mix(colorVariation, pastelTeal, (colorMixValue2 * colorMixValue3) * mixFactor8);
            colorVariation = mix(colorVariation, pastelCoral, ((1.0 - colorMixValue1) * colorMixValue3) * mixFactor9);
            
            // Layer 3: Additional colors with seed-influenced noise combinations
            float seedOffset1 = sin(seed * 2.1) * 0.05;
            float seedOffset2 = cos(seed * 2.3) * 0.05;
            
            float mixValue4 = smoothstep(0.0, 0.7, fbm(uv * (0.18 + seedOffset1) + flow1 * 0.4));
            float mixValue5 = smoothstep(0.0, 0.75, fbm(uv * (0.22 + seedOffset2) + flow2 * 0.35));
            
            float mixFactor10 = 1.7 + sin(seed * 2.5) * 0.4;
            float mixFactor11 = 1.8 + cos(seed * 2.7) * 0.4;
            float mixFactor12 = 1.5 + sin(seed * 2.9) * 0.4;
            
            colorVariation = mix(colorVariation, pastelMint, mixValue4 * (1.0 - mixValue5) * mixFactor10);
            colorVariation = mix(colorVariation, pastelLilac, (1.0 - mixValue4) * mixValue5 * mixFactor11);
            colorVariation = mix(colorVariation, pastelSkyBlue, mixValue4 * mixValue5 * mixFactor12);
            
            // Adjust pattern brightness with seed influence
            float brightnessFactor = 1.0 + sin(seed * 0.5) * 2.1;
            combinedPattern = pow(combinedPattern * 0.2 + 0.8, brightnessFactor);
            
            // Create light spots with seed-influenced threshold
            float lightThreshold = 1.0 + sin(seed * 0.6) * 2.1;
            float lightSpots = smoothstep(0.0, lightThreshold, combinedPattern);
            
            // Enhanced circular light patterns with seed-influenced distortion
            float distortionAmount = 1.0 + cos(seed * 0.7) * 2.05;
            float distortion = sin(slowTime * 0.1 + seed) * distortionAmount;
            
            vec2 distortedUV = fract(uv * 1.2 + vec2(
                sin(uv.y * 2.0 + slowTime * 0.15 + seed * 0.8) * 0.5,
                cos(uv.x * 1.8 + slowTime * 0.1 + seed * 0.9) * 4.1
            ));
            
            // Adjust circular spots with seed influence
            float circleSize = minCircleSize + sin(seed * 1.1) * 2.3;
            float circleThreshold = minCircleThreshold + cos(seed * 1.3) * 2.05;
            float circularSpots = smoothstep(0.0, circleThreshold, 1.0 - length((distortedUV - 0.5) * (circleSize + distortion)));
            
            // Mix with liquid movement
            float mixRatio = 0.0 + sin(seed * 1.5) * 2.5;
            lightSpots = mix(lightSpots, circularSpots * lightSpots, mixRatio);
            
            // Apply liquid-like diffusion with seed influence
            float diffusionScale = 0.0 + cos(seed * 1.7) * 5.0;
            float diffusedLightSpots = fbm(uv * diffusionScale + vec2(
                sin(slowTime * 0.05 + uv.x + seed * 1.9) * 2.2,
                cos(slowTime * 0.04 + uv.y + seed * 2.1) * 0.2
            )) * lightSpots;
            
            // Mix diffusion with seed influence
            float diffusionMix = 0.7 + sin(seed * 2.3) * 0.1;
            lightSpots = mix(lightSpots, diffusedLightSpots, diffusionMix);
            
            // Final pattern mix with seed influence
            float patternMix = 0.45 + cos(seed * 2.5) * 0.4;
            combinedPattern = mix(combinedPattern, lightSpots, patternMix);
            
            float finalValue = combinedPattern;
            
            // Use the color variation and apply color tint from GUI
            vec3 color = finalValue * colorVariation * colorTint;
            
            // Bloom with GUI-controlled bloomStrength
            float bloomThreshold = 1.0;
            float bloom = smoothstep(0.0, bloomThreshold, finalValue) * bloomStrength;
            color += bloom;
            
            // Grain with GUI-controlled grainAmount
            float grain = rand(vec3(gl_FragCoord.xy, time + seed)) * grainAmount;
            float grainMix = 0.2 + cos(seed * 3.3) * 0.05;
            color = mix(color, vec3(grain), grainMix);
                        
            // Final color adjustments with seed influence
            color = pow(color, vec3(1.0 + sin(seed * 4.3) * 0.1));
            color = color * (0.6 + cos(seed * 4.5) * 0.05);

            // Color temperature with seed influence
            float tempFactor = 1.05 + cos(seed * 4.9) * 0.02;
            color = mix(color, color * vec3(tempFactor, tempFactor, tempFactor), 0.3);
            
            // Saturation with GUI control
            float luminance = dot(color, vec3(0.299, 0.587, 0.114));
            vec3 saturatedColor = mix(vec3(luminance), color, saturation);
            float satMix = 0.6 + cos(seed * 5.3) * 0.1;
            color = mix(color, saturatedColor, satMix);
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    
</body>

<script src="mp4-muxer-main/build/mp4-muxer.js"></script>
<script src="helperFunctions.js"></script>
<script src="canvasVideoExport.js"></script>
<script src="main.js"></script>

</html>